/*

-----------------------------------------------------------------------------------------------------------------------------------
                                               Guidelines
-----------------------------------------------------------------------------------------------------------------------------------

The provided document is a guide for the project. Follow the instructions and take the necessary steps to finish
the project in the SQL file			

-----------------------------------------------------------------------------------------------------------------------------------

                                                         Queries
                                               
-----------------------------------------------------------------------------------------------------------------------------------*/
USE orders;

-- 1. WRITE A QUERY TO DISPLAY CUSTOMER FULL NAME WITH THEIR TITLE (MR/MS), BOTH FIRST NAME AND LAST NAME ARE IN UPPER CASE WITH 
-- CUSTOMER EMAIL ID, CUSTOMER CREATIONDATE AND DISPLAY CUSTOMERâ€™S CATEGORY AFTER APPLYING BELOW CATEGORIZATION RULES:
	-- i.IF CUSTOMER CREATION DATE YEAR <2005 THEN CATEGORY A
    -- ii.IF CUSTOMER CREATION DATE YEAR >=2005 AND <2011 THEN CATEGORY B
    -- iii.IF CUSTOMER CREATION DATE YEAR>= 2011 THEN CATEGORY C
    
    -- HINT: USE CASE STATEMENT, NO PERMANENT CHANGE IN TABLE REQUIRED. [NOTE: TABLES TO BE USED -ONLINE_CUSTOMER TABLE]

/*-----------------------------------------------------------------------
Describe online_customer;
select * from online_customer;
--------------------------------------------------------------------------- */

SELECT 
	CASE
		WHEN CUSTOMER_GENDER = 'F' THEN UPPER(CONCAT('MS', ' ', CUSTOMER_FNAME,' ', CUSTOMER_LNAME))
		WHEN CUSTOMER_GENDER = 'M' THEN UPPER(CONCAT('MR', ' ', CUSTOMER_FNAME,' ', CUSTOMER_LNAME))
		ELSE ' ' END AS FULL_NAME, CUSTOMER_EMAIL, CUSTOMER_CREATION_DATE,
	CASE 
		WHEN YEAR(CUSTOMER_CREATION_DATE) < 2005 THEN 'category a'
		WHEN YEAR(CUSTOMER_CREATION_DATE) >=2005 AND YEAR(CUSTOMER_CREATION_DATE) <2011 THEN 'category b'
		WHEN YEAR(CUSTOMER_CREATION_DATE) >=2011  THEN 'category c'
		ELSE '' END AS CATEGORY
FROM online_customer;

-- 2. WRITE A QUERY TO DISPLAY THE FOLLOWING INFORMATION FOR THE PRODUCTS, WHICH HAVE NOT BEEN SOLD:  PRODUCT_ID, PRODUCT_DESC, 
-- PRODUCT_QUANTITY_AVAIL, PRODUCT_PRICE,INVENTORY VALUES(PRODUCT_QUANTITY_AVAIL*PRODUCT_PRICE), NEW_PRICE AFTER APPLYING DISCOUNT 
-- AS PER BELOW CRITERIA. SORT THE OUTPUT WITH RESPECT TO DECREASING VALUE OF INVENTORY_VALUE.
	-- i.IF PRODUCT PRICE > 20,000 THEN APPLY 20% DISCOUNT
    -- ii.IF PRODUCT PRICE > 10,000 THEN APPLY 15% DISCOUNT
    -- iii.IF PRODUCT PRICE =< 10,000 THEN APPLY 10% DISCOUNT
    
    -- HINT: USE CASE STATEMENT, NO PERMANENT CHANGE IN TABLE REQUIRED. [NOTE: TABLES TO BE USED -PRODUCT, ORDER_ITEMS TABLE] 
    
/*-----------------------------------------------------------------------
    SELECT * FROM ORDER_ITEMS;
    SELECT * FROM product;
--------------------------------------------------------------------------- */
SELECT  
	p.PRODUCT_ID, 
	p.PRODUCT_DESC, 
	p.PRODUCT_QUANTITY_AVAIL, 
	p.PRODUCT_PRICE, 
	(p.PRODUCT_QUANTITY_AVAIL*p.PRODUCT_PRICE) AS INVENTORY_VALUES,
	CASE	
		WHEN p.PRODUCT_PRICE > 20000 THEN  p.PRODUCT_PRICE*0.80
		WHEN p.PRODUCT_PRICE > 10000 THEN   p.PRODUCT_PRICE*0.85
		WHEN p.PRODUCT_PRICE <= 10000 THEN  p.PRODUCT_PRICE* 0.90
		ELSE p.PRODUCT_PRICE END AS NEW_PRICE
FROM 
	product AS p
WHERE
	p.PRODUCT_ID NOT IN (
			SELECT oi.PRODUCT_ID 
			FROM ORDER_ITEMS oi
		)
ORDER BY
	INVENTORY_VALUES DESC;

-- ALTERNATIVE USING JOINS
SELECT 
    p.PRODUCT_ID,
    p.PRODUCT_DESC,
    p.PRODUCT_QUANTITY_AVAIL,
    p.PRODUCT_PRICE,
    (p.PRODUCT_QUANTITY_AVAIL * p.PRODUCT_PRICE) AS INVENTORY_VALUES,
    CASE
        WHEN p.PRODUCT_PRICE > 20000 THEN p.PRODUCT_PRICE * 0.80
        WHEN p.PRODUCT_PRICE > 10000 THEN p.PRODUCT_PRICE * 0.85
        ELSE p.PRODUCT_PRICE * 0.90
    END AS NEW_PRICE
FROM 
    PRODUCT p
LEFT JOIN 
    ORDER_ITEMS oi ON p.PRODUCT_ID = oi.PRODUCT_ID
WHERE 
    oi.PRODUCT_ID IS NULL
ORDER BY 
    INVENTORY_VALUES DESC;


-- 3. WRITE A QUERY TO DISPLAY PRODUCT_CLASS_CODE, PRODUCT_CLASS_DESCRIPTION, COUNT OF PRODUCT TYPE IN EACH PRODUCT CLASS, 
-- INVENTORY VALUE (P.PRODUCT_QUANTITY_AVAIL*P.PRODUCT_PRICE). INFORMATION SHOULD BE DISPLAYED FOR ONLY THOSE PRODUCT_CLASS_CODE 
-- WHICH HAVE MORE THAN 1,00,000 INVENTORY VALUE. SORT THE OUTPUT WITH RESPECT TO DECREASING VALUE OF INVENTORY_VALUE.
	-- [NOTE: TABLES TO BE USED -PRODUCT, PRODUCT_CLASS]
    
/*-----------------------------------------------------------------------
    SELECT * FROM product;
    SELECT * FROM product_class;
-----------------------------------------------------------------------*/
    
    SELECT 
		p.PRODUCT_CLASS_CODE, 
        pc.PRODUCT_CLASS_DESC, 
        COUNT(p.PRODUCT_ID) AS COUNT_OF_PRODUCT,
        SUM(p.PRODUCT_QUANTITY_AVAIL*p.PRODUCT_PRICE) AS INVENTORY_VALUES
	FROM 
		product AS p
    INNER JOIN
		product_class AS pc
    WHERE
		p.PRODUCT_CLASS_CODE = pc.PRODUCT_CLASS_CODE
    GROUP BY
		1, 2
    HAVING 
		SUM(p.PRODUCT_QUANTITY_AVAIL*p.PRODUCT_PRICE) > 100000
    ORDER BY
		INVENTORY_VALUES DESC;
    

-- 4. WRITE A QUERY TO DISPLAY CUSTOMER_ID, FULL NAME, CUSTOMER_EMAIL, CUSTOMER_PHONE AND COUNTRY OF CUSTOMERS WHO HAVE CANCELLED 
-- ALL THE ORDERS PLACED BY THEM(USE SUB-QUERY)
	-- [NOTE: TABLES TO BE USED - ONLINE_CUSTOMER, ADDRESSS, ORDER_HEADER]

/*-----------------------------------------------------------------------
SELECT * FROM online_customer;
SELECT * FROM address;
SELECT * FROM order_header;
-----------------------------------------------------------------------*/

SELECT 
	oc.CUSTOMER_ID,
    CONCAT(oc.CUSTOMER_FNAME, ' ', oc.CUSTOMER_LNAME) AS CUSTOMER_FULLNAME,
    oc.CUSTOMER_EMAIL,
    oc.CUSTOMER_PHONE,
    a.COUNTRY
FROM
	online_customer AS oc
INNER JOIN 
    address AS a ON oc.ADDRESS_ID = a.ADDRESS_ID
WHERE 
    NOT EXISTS (
        SELECT 1
        FROM order_header oh
        WHERE oh.CUSTOMER_ID = oc.CUSTOMER_ID
        AND oh.ORDER_STATUS <> 'Cancelled'
    );

-- 5. WRITE A QUERY TO DISPLAY SHIPPER NAME, CITY TO WHICH IT IS CATERING, NUMBER OF CUSTOMER CATERED BY THE SHIPPER IN THE CITY AND 
-- NUMBER OF CONSIGNMENTS DELIVERED TO THAT CITY FOR SHIPPER DHL(9 ROWS)
	-- [NOTE: TABLES TO BE USED -SHIPPER, ONLINE_CUSTOMER, ADDRESSS, ORDER_HEADER]
	
    /*-----------------------------------------------------------------------
    SELECT * FROM shipper;
    SELECT * FROM online_customer;
    SELECT * FROM address;
	SELECT * FROM order_header;
    -----------------------------------------------------------------------*/
     
SELECT 
    s.SHIPPER_NAME,
    a.CITY,
    COUNT(DISTINCT oc.CUSTOMER_ID) AS NUM_OF_CUSTOMERS,
    COUNT(oh.ORDER_ID) AS NUM_OF_CONSIGNMENTS
FROM 
    shipper s
INNER JOIN 
    order_header oh ON s.SHIPPER_ID = oh.SHIPPER_ID
INNER JOIN 
    online_customer oc ON oh.CUSTOMER_ID = oc.CUSTOMER_ID
INNER JOIN 
    address a ON oc.ADDRESS_ID = a.ADDRESS_ID
WHERE 
    s.SHIPPER_NAME = 'DHL' 
GROUP BY 
    s.SHIPPER_NAME, a.CITY
ORDER BY 
    NUM_OF_CONSIGNMENTS DESC
LIMIT 9;


-- 6. WRITE A QUERY TO DISPLAY CUSTOMER ID, CUSTOMER FULL NAME, TOTAL QUANTITY AND TOTAL VALUE (QUANTITY*PRICE) SHIPPED WHERE MODE 
-- OF PAYMENT IS CASH AND CUSTOMER LAST NAME STARTS WITH 'G'
	-- [NOTE: TABLES TO BE USED -ONLINE_CUSTOMER, ORDER_ITEMS, PRODUCT, ORDER_HEADER]
    
/*-----------------------------------------------------------------------
    SELECT * FROM online_customer;
    SELECT * FROM order_items;
    SELECT * FROM order_header;
    SELECT * FROM product;
-----------------------------------------------------------------------*/

SELECT 
	oc.CUSTOMER_ID,
    CONCAT(oc.CUSTOMER_FNAME, ' ', oc.CUSTOMER_LNAME) AS CUSTOMER_FULLNAME,
    SUM(oi.PRODUCT_QUANTITY) AS TOTAL_QUANTITY,
    SUM(p.PRODUCT_PRICE * oi.PRODUCT_QUANTITY) AS TOTAL_VALUE
FROM online_customer AS oc 
INNER JOIN 
	order_header AS oh ON oc.CUSTOMER_ID = oh.CUSTOMER_ID
INNER JOIN
	order_items AS oi ON oh.ORDER_ID = oi.ORDER_ID
INNER JOIN
	product AS P ON oi.PRODUCT_ID = p.PRODUCT_ID
WHERE 
	oh.ORDER_STATUS = 'SHIPPED' AND oh.PAYMENT_MODE = 'CASH' AND oc.CUSTOMER_LNAME LIKE 'G%'
GROUP BY 
    oc.CUSTOMER_ID    
ORDER BY 
    TOTAL_VALUE DESC;

    
-- 7. WRITE A QUERY TO DISPLAY ORDER_ID AND VOLUME OF BIGGEST ORDER (IN TERMS OF VOLUME) THAT CAN FIT IN CARTON ID 10  
	-- [NOTE: TABLES TO BE USED -CARTON, ORDER_ITEMS, PRODUCT]
    
/*-----------------------------------------------------------------------
    SELECT * FROM carton;
    select * FROM order_items;
    SELECT * FROM product;
-----------------------------------------------------------------------*/
    
SELECT 
    oi.ORDER_ID,
    SUM(p.LEN*p.WIDTH*p.HEIGHT*p.WEIGHT * oi.PRODUCT_QUANTITY) AS ORDER_VOLUME,
    (c.LEN * c.WIDTH * c.HEIGHT) AS CARTON_CAPACITY
FROM 
    order_items oi
INNER JOIN 
    product p ON oi.PRODUCT_ID = p.PRODUCT_ID
INNER JOIN 
    carton c ON c.CARTON_ID = 10  
GROUP BY 
    oi.ORDER_ID
HAVING 
    ORDER_VOLUME <= CARTON_CAPACITY
ORDER BY 
    ORDER_VOLUME DESC
LIMIT 5; 


-- 8. WRITE A QUERY TO DISPLAY PRODUCT_ID, PRODUCT_DESC, PRODUCT_QUANTITY_AVAIL, QUANTITY SOLD, AND SHOW INVENTORY STATUS OF 
-- PRODUCTS AS BELOW AS PER BELOW CONDITION:
	-- A.FOR ELECTRONICS AND COMPUTER CATEGORIES, 
		-- i.IF SALES TILL DATE IS ZERO THEN SHOW 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY',
        -- ii.IF INVENTORY QUANTITY IS LESS THAN 10% OF QUANTITY SOLD, SHOW 'LOW INVENTORY, NEED TO ADD INVENTORY', 
        -- iii.IF INVENTORY QUANTITY IS LESS THAN 50% OF QUANTITY SOLD, SHOW 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY', 
        -- iv.IF INVENTORY QUANTITY IS MORE OR EQUAL TO 50% OF QUANTITY SOLD, SHOW 'SUFFICIENT INVENTORY'
	-- B.FOR MOBILES AND WATCHES CATEGORIES, 
		-- i.IF SALES TILL DATE IS ZERO THEN SHOW 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY', 
        -- ii.IF INVENTORY QUANTITY IS LESS THAN 20% OF QUANTITY SOLD, SHOW 'LOW INVENTORY, NEED TO ADD INVENTORY',  
        -- iii.IF INVENTORY QUANTITY IS LESS THAN 60% OF QUANTITY SOLD, SHOW 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY', 
        -- iv.IF INVENTORY QUANTITY IS MORE OR EQUAL TO 60% OF QUANTITY SOLD, SHOW 'SUFFICIENT INVENTORY'
	-- C.REST OF THE CATEGORIES, 
		-- i.IF SALES TILL DATE IS ZERO THEN SHOW 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY', 
        -- ii.IF INVENTORY QUANTITY IS LESS THAN 30% OF QUANTITY SOLD, SHOW 'LOW INVENTORY, NEED TO ADD INVENTORY',  
        -- iii.IF INVENTORY QUANTITY IS LESS THAN 70% OF QUANTITY SOLD, SHOW 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY', 
        -- iv. IF INVENTORY QUANTITY IS MORE OR EQUAL TO 70% OF QUANTITY SOLD, SHOW 'SUFFICIENT INVENTORY'
        
			-- [NOTE: TABLES TO BE USED -PRODUCT, PRODUCT_CLASS, ORDER_ITEMS] (USE SUB-QUERY)
            
/*-----------------------------------------------------------------------
SELECT * FROM product;
SELECT * FROM product_class;
SELECT * FROM order_items;
-----------------------------------------------------------------------*/
            
	SELECT 
		p.PRODUCT_ID,
		p.PRODUCT_DESC,
		p.PRODUCT_QUANTITY_AVAIL,
		COALESCE(SUM(oi.PRODUCT_QUANTITY), 0) AS QUANTITY_SOLD,
    CASE 
        -- For Electronics and Computer categories
        WHEN pc.PRODUCT_CLASS_DESC IN ('Electronics', 'Computer') THEN
            CASE 
                WHEN COALESCE(SUM(oi.PRODUCT_QUANTITY), 0) = 0 THEN 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.10 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'LOW INVENTORY, NEED TO ADD INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.50 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY'
                ELSE 'SUFFICIENT INVENTORY'
            END
        -- For Mobiles and Watches categories
        WHEN pc.PRODUCT_CLASS_DESC IN ('Mobile', 'Watch') THEN
            CASE 
                WHEN COALESCE(SUM(oi.PRODUCT_QUANTITY), 0) = 0 THEN 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.20 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'LOW INVENTORY, NEED TO ADD INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.60 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY'
                ELSE 'SUFFICIENT INVENTORY'
            END
        -- For all other categories
        ELSE
            CASE 
                WHEN COALESCE(SUM(oi.PRODUCT_QUANTITY), 0) = 0 THEN 'NO SALES IN PAST, GIVE DISCOUNT TO REDUCE INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.30 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'LOW INVENTORY, NEED TO ADD INVENTORY'
                WHEN p.PRODUCT_QUANTITY_AVAIL < 0.70 * COALESCE(SUM(oi.PRODUCT_QUANTITY), 1) THEN 'MEDIUM INVENTORY, NEED TO ADD SOME INVENTORY'
                ELSE 'SUFFICIENT INVENTORY'
            END
    END AS INVENTORY_STATUS
FROM 
    product p
INNER JOIN 
    product_class pc ON p.PRODUCT_CLASS_CODE = pc.PRODUCT_CLASS_CODE
LEFT JOIN 
    order_items oi ON p.PRODUCT_ID = oi.PRODUCT_ID  -- Left join to calculate sales even if there are no orders
GROUP BY 
    p.PRODUCT_ID, p.PRODUCT_DESC, p.PRODUCT_QUANTITY_AVAIL, pc.PRODUCT_CLASS_DESC
ORDER BY 
    QUANTITY_SOLD DESC;

	
    
    -- 9. WRITE A QUERY TO DISPLAY PRODUCT_ID, PRODUCT_DESC AND TOTAL QUANTITY OF PRODUCTS WHICH ARE SOLD TOGETHER WITH PRODUCT ID 201 
-- AND ARE NOT SHIPPED TO CITY BANGALORE AND NEW DELHI. DISPLAY THE OUTPUT IN DESCENDING ORDER WITH RESPECT TO TOT_QTY.(USE SUB-QUERY)
	-- [NOTE: TABLES TO BE USED -ORDER_ITEMS,PRODUCT,ORDER_HEADER, ONLINE_CUSTOMER, ADDRESS]
    
/*-----------------------------------------------------------------------    
   SELECT * FROM online_customer;
   SELECT * FROM order_items;
    SELECT * FROM order_header;
    SELECT * FROM product;
    SELECT * FROM address;
-----------------------------------------------------------------------*/
    
    SELECT
		p.PRODUCT_ID, 
        p.PRODUCT_DESC,
        SUM(oi.PRODUCT_QUANTITY) AS TOT_QTY
    FROM product AS p
    INNER JOIN
		order_items AS oi ON p.PRODUCT_ID = oi.PRODUCT_ID
	INNER JOIN 
		order_header AS oh ON oi.ORDER_ID = oh.ORDER_ID
    INNER JOIN
		online_customer AS oc ON oh.CUSTOMER_ID = oc.CUSTOMER_ID
	INNER JOIN 
		address AS a ON oc.ADDRESS_ID = a.ADDRESS_ID
    WHERE oi.ORDER_ID IN 
						(SELECT 
							oii.ORDER_ID 
						FROM 
							order_items oii
						WHERE oii.PRODUCT_ID = 201)
						AND a.CITY NOT IN ('Bangalore', 'New Delhi')
GROUP BY 1,2
ORDER BY TOT_QTY DESC;
    
   

-- 10. WRITE A QUERY TO DISPLAY THE ORDER_ID,CUSTOMER_ID AND CUSTOMER FULLNAME AND TOTAL QUANTITY OF PRODUCTS SHIPPED FOR ORDER IDS 
-- WHICH ARE EVENAND SHIPPED TO ADDRESS WHERE PINCODE IS NOT STARTING WITH "5" 
	-- [NOTE: TABLES TO BE USED - ONLINE_CUSTOMER,ORDER_HEADER, ORDER_ITEMS, ADDRESS]
   
  /*----------------------------------------------------------------------- 
	-- SELECT * FROM online_customer;
    -- SELECT * FROM order_items;
    -- SELECT * FROM order_header;
    -- SELECT * FROM address;
-----------------------------------------------------------------------*/
    
    SELECT 
		oi.ORDER_ID,
		oc.CUSTOMER_ID,
		CONCAT(oc.CUSTOMER_FNAME, ' ', oc.CUSTOMER_LNAME) AS CUSTOMER_FULLNAME,
        SUM(oi.PRODUCT_QUANTITY) AS TOTAL_QUANTITY
    FROM 
		order_items oi
	INNER JOIN
		order_header AS oh ON oi.ORDER_ID = oh.ORDER_ID
	INNER JOIN
		online_customer AS oc ON oh.CUSTOMER_ID = oc.CUSTOMER_ID
	INNER JOIN
		address AS a ON oc.ADDRESS_ID = a.ADDRESS_ID
	WHERE 
		oi.ORDER_ID MOD 2 = 0
        AND a.PINCODE  NOT LIKE '5%'
	GROUP BY 
		oi.ORDER_ID, 
		oc.CUSTOMER_ID, 
        CUSTOMER_FULLNAME;
                